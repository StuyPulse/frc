/*----------------------------------------------------------------------------*/
/* Copyright (c) FIRST 2008. All Rights Reserved.							  */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in $(WIND_BASE)/WPILib.  */
/*----------------------------------------------------------------------------*/

#include "Task.h"

#include "Utility.h"
#include "WPIStatus.h"
#include <string.h>

extern "C" { INT32 ERRNO; }

/**
 * Create but don't launch a task.
 * @param name The name of the task
 * @param priority The VxWorks priority for the task.
 */
Task::Task(char* name, FUNCPTR function, INT32 priority, UINT32 stackSize)
{
	m_taskID = 0;
	m_function = function;
	m_priority = priority;
	m_stackSize = stackSize;
	m_taskName = new char[strlen(name) + 1];
	strcpy(m_taskName, name);
}

Task::~Task(void)
{
	if (m_taskID != 0)
		taskDelete(m_taskID);
	delete [] m_taskName;
	m_taskID = 0;
	m_taskName = NULL;
}

/**
 * Handles errors generated by task related code.
 */
bool Task::HandleError(STATUS results)
{
	if (results != ERROR) return true;
	switch(ERRNO)
	{
	case S_objLib_OBJ_ID_ERROR:
		wpi_fatal(TaskIDError);
		break;
		
	case S_objLib_OBJ_DELETED:
		wpi_fatal(TaskDeletedError);
		break;
		
	case S_taskLib_ILLEGAL_OPTIONS:
		wpi_fatal(TaskOptionsError);
		break;
		
	case S_memLib_NOT_ENOUGH_MEMORY:
		wpi_fatal(TaskMemoryError);
		break;
		
	case S_taskLib_ILLEGAL_PRIORITY:
		wpi_fatal(TaskPriorityError);
		break;
		
	default:
		wpi_fatal(TaskError);
	}
	return false;
}

/**
 * Runs this task.
 * If it is already running or unable to start, it fails and returns false.
 */
bool Task::Run(INT32 arg)
{
	m_taskID = taskSpawn(m_taskName,
						m_priority,
						VX_FP_TASK,							// options
						m_stackSize,						// stack size
						m_function,							// function to start
						arg,								// parameter 1 - pointer to this class
						0, 0, 0, 0, 0, 0, 0, 0, 0);			// additional unused parameters
	return HandleError(m_taskID);
}

/**
 * Restarts a running task.
 * If the task isn't started, it starts it.
 * If the task is running and we are unable to kill the previous instance, returns false.
 */
bool Task::Restart(void)
{
	return HandleError(taskRestart(m_taskID));
}

/**
 * Kills the running task.
 * Returns true on success false if the task doesn't exist or we are unable to kill it.
 */
bool Task::Delete(void)
{
	return HandleError(taskDelete(m_taskID));
}

/**
 * Pauses a running task.
 * Returns true on success, false if unable to pause or the task isn't running.
 */
bool Task::Suspend(void)
{
	return HandleError(taskSuspend(m_taskID));
}

/**
 * Resumes a paused task.
 * Returns true on success, false if unable to resume or if the task isn't running/paused.
 */
bool Task::Resume(void)
{
	return HandleError(taskResume(m_taskID));
}

/**
 * Verifies a task is running.
 * @returns true on success.
 */
bool Task::Verify(void)
{
	return taskIdVerify(m_taskID);
}

/**
 * Gets the priority of a task.
 * @returns task priority or 0 if an error occured
 */
INT32 Task::GetPriority(void)
{
	if (HandleError(taskPriorityGet(m_taskID, &m_priority)))
		return m_priority;
	else
		return 0;
}

/**
 * Sets the priority of the task.
 * Range: ? to ???
 * @returns true on success.
 */
bool Task::SetPriority(INT32 priority)
{
	m_priority = priority;
	return HandleError(taskPrioritySet(m_taskID, m_priority));
}

/**
 * Returns the name of the task.
 * @returns Pointer to the name of the task or NULL if not allocated
 */
char* Task::GetName(void)
{
	return m_taskName;
}

/**
 * Get the ID of a task
 * @returns task ID of this task.
 */
INT32 Task::GetID(void)
{
	return m_taskID;
}

